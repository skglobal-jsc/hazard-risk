<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Hazard Risk GeoJSON Editor</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', 'Calibri', 'Trebuchet MS', 'Ubuntu', Arial, sans-serif;
            background: #f6f8fa;
        }
        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        .map-panel {
            flex: 1 1 0;
            min-width: 0;
            position: relative;
            background: #eaeaea;
        }
        #map {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            z-index: 1;
        }
        .side-panel {
            width: 420px;
            background: #fff;
            border-left: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            box-shadow: -2px 0 8px rgba(0,0,0,0.04);
        }
        .tabs {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
        }
        .tab-btn {
            flex: 1;
            padding: 12px 0;
            text-align: center;
            background: #f6f8fa;
            border: none;
            border-bottom: 2px solid transparent;
            font-size: 15px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .tab-btn.active {
            background: #fff;
            border-bottom: 2px solid #1976d2;
            color: #1976d2;
            font-weight: bold;
        }
        .tab-content {
            flex: 1;
            padding: 18px 18px 12px 18px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .geojson-textarea {
            width: 100%;
            flex: 1 1 0;
            min-height: 0;
            height: 100%;
            font-family: monospace;
            font-size: 13px;
            border-radius: 6px;
            border: 1px solid #d0d0d0;
            padding: 10px;
            resize: none;
            background: #f9f9f9;
        }
        .config-form label {
            font-weight: bold;
            margin-top: 12px;
            display: block;
            font-size: 13px;
        }
        .config-form input {
            width: 100%;
            padding: 7px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-top: 4px;
            font-size: 13px;
            background: #f9f9f9;
        }
        .config-form {
            margin-top: 8px;
        }
        .config-form .form-group {
            margin-bottom: 14px;
        }
        .hazard-config {
            border-top: 1px solid #e0e0e0;
            margin-top: 20px;
            padding-top: 20px;
        }
        .hazard-config h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }
        .level-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            padding: 8px;
            background: #f9f9f9;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }
        .level-item:hover {
            background: #f0f0f0;
        }
        .level-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ccc;
            cursor: pointer;
        }
        .level-inputs {
            flex: 1;
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .level-inputs input {
            margin: 0;
            padding: 4px 6px;
            font-size: 12px;
        }
        .level-inputs input[type="text"] {
            flex: 1;
        }
        .level-inputs input[type="color"] {
            width: 30px;
            height: 25px;
            padding: 0;
            border: none;
            border-radius: 3px;
        }
        .add-level-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
        }
        .add-level-btn:hover {
            background: #45a049;
        }
        .remove-level-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }
        .remove-level-btn:hover {
            background: #da190b;
        }
        .water-colors {
            margin-top: 15px;
        }
        .water-colors h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #555;
        }
        .color-list {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .color-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .color-item input[type="color"] {
            width: 25px;
            height: 20px;
            border: none;
            border-radius: 2px;
        }
        .add-color-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }
        .add-color-btn:hover {
            background: #1976D2;
        }
        .remove-color-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 2px 6px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 10px;
        }
        .remove-color-btn:hover {
            background: #da190b;
        }
        @media (max-width: 900px) {
            .side-panel { width: 100vw; position: absolute; z-index: 10; right: 0; top: 0; height: 60vh; }
            .container { flex-direction: column; }
            .map-panel { height: 40vh; }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="map-panel">
        <div id="map"></div>
    </div>
    <div class="side-panel">
        <div class="tabs">
            <button class="tab-btn active" id="tabGeoJsonBtn" onclick="showTab('geojson')">GeoJSON</button>
            <button class="tab-btn" id="tabConfigBtn" onclick="showTab('config')">Config</button>
        </div>
        <div class="tab-content" id="tabGeoJson">
            <textarea id="geojsonText" class="geojson-textarea"></textarea>
        </div>
        <div class="tab-content" id="tabConfig" style="display:none;">
            <form class="config-form" autocomplete="off" onsubmit="return false;">
                <div class="form-group">
                  <label for="baseUrl">Water Map Tile URL</label>
                  <input readonly type="text" id="baseUrl" value="https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png">
                </div>
                <div class="form-group" style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
                    <label for="hazardUrl" style="margin: 0; flex: 1;">Hazard Tile URL</label>
                    <label style="margin: 0; font-size: 12px; font-weight: normal; display: flex; align-items: center; gap: 4px; white-space: nowrap;">
                        <input type="checkbox" id="showHazardLayer" checked> <span>Show Layer</span>
                    </label>
                </div>
                <input type="text" id="hazardUrl" value="https://disaportaldata.gsi.go.jp/raster/01_flood_l1_shinsuishin_newlegend_data/{z}/{x}/{y}.png">

                <div class="form-group">
                    <label for="gridSize">Grid Size (meters)</label>
                    <input type="number" id="gridSize" value="100" min="10" max="1000">
                </div>
                <div class="form-group">
                    <label for="zoom">Zoom level</label>
                    <input type="number" id="zoom" value="14" min="2" max="20">
                </div>
            </form>

            <div class="hazard-config">
                <h3>Hazard Configuration</h3>
                <div class="form-group">
                    <label for="hazardName">Hazard Name</label>
                    <input type="text" id="hazardName" value="Tsunami Depth (GSI Japan)">
                </div>

                <div class="form-group">
                    <label>Risk Levels</label>
                    <div id="riskLevels">
                        <!-- Risk levels will be populated by JavaScript -->
                    </div>
                    <button type="button" class="add-level-btn" onclick="addRiskLevel()">+ Add Level</button>
                </div>

                <div class="water-colors">
                    <h4>Water Colors</h4>
                    <div id="waterColors" class="color-list">
                        <!-- Water colors will be populated by JavaScript -->
                    </div>
                    <button type="button" class="add-color-btn" onclick="addWaterColor()">+ Add Color</button>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script>
// --- Tab logic ---
function showTab(tab) {
    document.getElementById('tabGeoJson').style.display = tab === 'geojson' ? '' : 'none';
    document.getElementById('tabConfig').style.display = tab === 'config' ? '' : 'none';
    document.getElementById('tabGeoJsonBtn').classList.toggle('active', tab === 'geojson');
    document.getElementById('tabConfigBtn').classList.toggle('active', tab === 'config');
}

// --- Map & Draw logic ---
let map, drawnItems, drawControl, ignoreGeoJsonChange = false;
let hazardLayer = null;
let isAnalyzing = false; // Prevent multiple API calls

// --- Hazard Configuration ---
let hazardConfig = {
    name: "Flood Depth (GSI Japan)",
    levels: {
        "0": { name: "level0", color: "#FFFFFF", description: "0m" },
        "1": { name: "level1", color: "#FFFFB3", description: "<0.3m" },
        "2": { name: "level2", color: "#F7F5A9", description: "<0.5m" },
        "3": { name: "level3", color: "#F8E1A6", description: "0.5~1m" },
        "4": { name: "level4", color: "#FFD8C0", description: "0.5~3m" },
        "5": { name: "level5", color: "#FFB7B7", description: "3~5m" },
        "6": { name: "level6", color: "#FF9191", description: "5~10m" },
        "7": { name: "level7", color: "#F285C9", description: "10~20m" },
        "8": { name: "level8", color: "#DC7ADC", description: ">20m" }
    },
    waterColors: ["#bed2ff"]
};

function renderRiskLevels() {
    const container = document.getElementById('riskLevels');
    container.innerHTML = '';

    Object.entries(hazardConfig.levels).forEach(([level, config]) => {
        const levelItem = document.createElement('div');
        levelItem.className = 'level-item';
        levelItem.innerHTML = `
            <div class="level-color" style="background-color: ${config.color}"></div>
            <div class="level-inputs">
                <input type="text" placeholder="Name" value="${config.name}" onchange="updateLevel('${level}', 'name', this.value)">
                <input type="text" placeholder="Description" value="${config.description}" onchange="updateLevel('${level}', 'description', this.value)">
                <input type="color" value="${config.color}" onchange="updateLevel('${level}', 'color', this.value)">
                <button type="button" class="remove-level-btn" onclick="removeLevel('${level}')">×</button>
            </div>
        `;
        container.appendChild(levelItem);
    });
}

function renderWaterColors() {
    const container = document.getElementById('waterColors');
    container.innerHTML = '';

    hazardConfig.waterColors.forEach((color, index) => {
        const colorItem = document.createElement('div');
        colorItem.className = 'color-item';
        colorItem.innerHTML = `
            <input type="color" value="${color}" onchange="updateWaterColor(${index}, this.value)">
            <button type="button" class="remove-color-btn" onclick="removeWaterColor(${index})">×</button>
        `;
        container.appendChild(colorItem);
    });
}

function updateLevel(level, field, value) {
    hazardConfig.levels[level][field] = value;
    renderRiskLevels();
    saveConfigToLocalStorage();
}

function removeLevel(level) {
    delete hazardConfig.levels[level];
    renderRiskLevels();
    saveConfigToLocalStorage();
}

function addRiskLevel() {
    const newLevel = Object.keys(hazardConfig.levels).length;
    hazardConfig.levels[newLevel] = {
        name: `level${newLevel}`,
        color: "#FFFFFF",
        description: "New level"
    };
    renderRiskLevels();
    saveConfigToLocalStorage();
}

function updateWaterColor(index, color) {
    hazardConfig.waterColors[index] = color;
    renderWaterColors();
    saveConfigToLocalStorage();
}

function removeWaterColor(index) {
    hazardConfig.waterColors.splice(index, 1);
    renderWaterColors();
    saveConfigToLocalStorage();
}

function addWaterColor() {
    hazardConfig.waterColors.push("#FFFFFF");
    renderWaterColors();
    saveConfigToLocalStorage();
}

function getHazardConfig() {
    return {
        name: document.getElementById('hazardName').value,
        levels: { ...hazardConfig.levels },
        waterColors: [...hazardConfig.waterColors]
    };
}

// --- LocalStorage Management ---
function saveConfigToLocalStorage() {
    const config = {
        hazardUrl: document.getElementById('hazardUrl').value,
        gridSize: document.getElementById('gridSize').value,
        zoom: document.getElementById('zoom').value,
        showHazardLayer: document.getElementById('showHazardLayer').checked,
        hazardName: document.getElementById('hazardName').value,
        hazardConfig: hazardConfig
    };
    localStorage.setItem('hazardRiskConfig', JSON.stringify(config));
}

function loadConfigFromLocalStorage() {
    const savedConfig = localStorage.getItem('hazardRiskConfig');
    if (savedConfig) {
        try {
            const config = JSON.parse(savedConfig);

            // Load basic config
            if (config.hazardUrl) document.getElementById('hazardUrl').value = config.hazardUrl;
            if (config.gridSize) document.getElementById('gridSize').value = config.gridSize;
            if (config.zoom) document.getElementById('zoom').value = config.zoom;
            if (config.showHazardLayer !== undefined) document.getElementById('showHazardLayer').checked = config.showHazardLayer;
            if (config.hazardName) document.getElementById('hazardName').value = config.hazardName;

            // Load hazard config
            if (config.hazardConfig) {
                hazardConfig = config.hazardConfig;
            }

            return true;
        } catch (e) {
            console.error('Error loading config from localStorage:', e);
            return false;
        }
    }
    return false;
}

function applyConfigToMap() {
    // Update map with current config
    if (map) {
        // Update hazard layer only - keep OpenStreetMap as base
        updateHazardLayer();
    }
}

function updateHazardLayer() {
    const url = document.getElementById('hazardUrl').value;
    const show = document.getElementById('showHazardLayer').checked;
    if (hazardLayer) {
        map.removeLayer(hazardLayer);
        hazardLayer = null;
    }
    if (show && url) {
        hazardLayer = L.tileLayer(url, { opacity: 0.7, attribution: 'Hazard Data' });
        hazardLayer.addTo(map);
    }
}

function initMap() {
    map = L.map('map', {
        center: [35.6895, 139.6917], // Tokyo
        zoom: 14,
        minZoom: 2,
        maxZoom: 18
    });
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    drawnItems = new L.FeatureGroup().addTo(map);
    drawControl = new L.Control.Draw({
        edit: { featureGroup: drawnItems, remove: true },
        draw: {
            polygon: true,
            rectangle: true,
            circle: true,
            marker: false,
            polyline: false,
            circlemarker: false
        }
    });
    map.addControl(drawControl);
    map.on(L.Draw.Event.CREATED, function (e) {
        drawnItems.addLayer(e.layer);
        syncGeoJsonText();
        rebindAllRiskPopups();
    });
    map.on(L.Draw.Event.EDITED, function (e) {
        syncGeoJsonText();
        rebindAllRiskPopups();
    });
    map.on(L.Draw.Event.DELETED, function (e) {
        syncGeoJsonText();
        rebindAllRiskPopups();
    });
    updateHazardLayer();
}

// --- GeoJSON sync logic ---
function syncGeoJsonText() {
    ignoreGeoJsonChange = true;
    const geojson = drawnItems.toGeoJSON();
    document.getElementById('geojsonText').value = JSON.stringify(geojson, null, 2);
    ignoreGeoJsonChange = false;
}

// Hàm chuyển đổi Circle thành Polygon
function circleToPolygon(center, radius, numPoints = 32) {
    const coordinates = [];
    const [lng, lat] = center;

    for (let i = 0; i < numPoints; i++) {
        const angle = (i / numPoints) * 2 * Math.PI;

        // Tính toán offset theo hướng bắc-nam và đông-tây
        const latOffset = (radius / 111320) * Math.cos(angle);
        const lngOffset = (radius / (111320 * Math.cos(lat * Math.PI / 180))) * Math.sin(angle);

        coordinates.push([lng + lngOffset, lat + latOffset]);
    }

    // Đóng polygon
    coordinates.push(coordinates[0]);
    return coordinates;
}

// Lắng nghe click vào từng layer để phân tích risk
function bindRiskPopupToLayer(layer) {
    // Remove existing click handlers to prevent duplicate calls
    layer.off('click');
    layer.on('click', async function(e) {
        // Prevent multiple API calls
        if (isAnalyzing) {
            console.log('Analysis already in progress, skipping...');
            return;
        }

        isAnalyzing = true;

        // Lấy geojson của layer
        const geojson = layer.toGeoJSON();

        // Xử lý trường hợp Circle (Point) thành Polygon
        let polygonGeometry = geojson.geometry;
        if (geojson.geometry.type === 'Point' && layer instanceof L.Circle) {
            const center = geojson.geometry.coordinates;
            const radius = layer.getRadius(); // Lấy bán kính của circle
            const polygonCoords = circleToPolygon(center, radius);
            polygonGeometry = {
                type: 'Polygon',
                coordinates: [polygonCoords]
            };
        }

        // Lấy config hiện tại
        const hazardUrl = document.getElementById('hazardUrl').value;
        const baseUrl = 'https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png';
        const gridSize = parseInt(document.getElementById('gridSize').value);
        const zoom = parseInt(document.getElementById('zoom').value);
        // Hiển thị popup loading
        layer.bindPopup('Calculating risk...').openPopup(e.latlng || undefined);
        try {
            // Gọi API phân tích risk
            console.log('original geojson', geojson.geometry);
            console.log('processed geometry', polygonGeometry);

            // Chuẩn bị payload cho API
            const payload = {
                polygon: polygonGeometry,
                hazardTileUrl: hazardUrl,
                baseTileUrl: baseUrl,
                gridSize,
                zoom,
                hazardConfig: getHazardConfig(),
                currentLocation: {
                    lat: e.latlng.lat,
                    lon: e.latlng.lng
                }
            };

            // Gọi API
            const response = await fetch('https://dev-public-api.uni-voice.biz/api/v1/hazardmap/risk-analysis', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();

            if (result.status !== 'OK') {
                throw new Error('API returned error status');
            }

            // Hiển thị kết quả risk
            let html = '<b>Risk Analysis</b><br/>';
            html += `<b>Total Points:</b> ${result.data.stats.total}<br/>`;
            html += `<b>Water Points:</b> ${result.data.waterCount}<br/>`;
            html += '<b>Risk Distribution:</b><br/>';
            Object.entries(result.data.stats).forEach(([level, count]) => {
                if (level !== 'total' && count > 0) {
                    const ratio = ((count / result.data.stats.total) * 100).toFixed(1);
                    html += `Level ${level}: ${count} (${ratio}%)<br/>`;
                }
            });

            // Thêm thông tin về điểm gần nhất nếu có
            if (result.data.nearestPoints) {
                html += '<br/><b>Nearest Points:</b><br/>';
                Object.entries(result.data.nearestPoints).forEach(([level, point]) => {
                    html += `Level ${level}: ${point.distance.toFixed(1)}m away<br/>`;
                });
            }

            layer.setPopupContent(html);
        } catch (err) {
            console.error(err);
            layer.setPopupContent('Risk analysis failed! Error: ' + err.message);
        } finally {
            isAnalyzing = false;
        }
    });
}

// Gắn lại sự kiện cho tất cả layer mỗi khi vẽ/sửa/xóa
function rebindAllRiskPopups() {
    drawnItems.eachLayer(function(layer) {
        // Xử lý tất cả các loại layer có thể phân tích risk
        if (layer instanceof L.Polygon || layer instanceof L.Rectangle || layer instanceof L.Circle) {
            bindRiskPopupToLayer(layer);
        }
    });
}

document.addEventListener('DOMContentLoaded', function() {
    // Load config from localStorage first
    const configLoaded = loadConfigFromLocalStorage();

    initMap();
    syncGeoJsonText();

    // Khởi tạo giao diện cấu hình hazard
    renderRiskLevels();
    renderWaterColors();

    // Apply loaded config to map if config was loaded
    if (configLoaded) {
        applyConfigToMap();
    }

    // Khi sửa textarea, cập nhật lại map
    document.getElementById('geojsonText').addEventListener('input', function() {
        if (ignoreGeoJsonChange) return;
        try {
            const geojson = JSON.parse(this.value);
            drawnItems.clearLayers();
            L.geoJSON(geojson, {
                onEachFeature: function (feature, layer) {
                    drawnItems.addLayer(layer);
                }
            });
        } catch (e) { /* ignore parse error */ }
    });

    // Sự kiện show/hide hazard layer
    document.getElementById('showHazardLayer').addEventListener('change', function() {
        updateHazardLayer();
        saveConfigToLocalStorage();
    });

    // Add event listeners for config changes
    document.getElementById('hazardUrl').addEventListener('change', function() {
        updateHazardLayer();
        saveConfigToLocalStorage();
    });
    document.getElementById('hazardUrl').addEventListener('blur', function() {
        updateHazardLayer();
        saveConfigToLocalStorage();
    });

    document.getElementById('gridSize').addEventListener('change', saveConfigToLocalStorage);
    document.getElementById('gridSize').addEventListener('blur', saveConfigToLocalStorage);
    document.getElementById('zoom').addEventListener('change', saveConfigToLocalStorage);
    document.getElementById('zoom').addEventListener('blur', saveConfigToLocalStorage);
    document.getElementById('hazardName').addEventListener('change', saveConfigToLocalStorage);
    document.getElementById('hazardName').addEventListener('blur', saveConfigToLocalStorage);
});
</script>
</body>
</html>
